#!/usr/bin/env bash
set -euo pipefail

REPO=""                                # default: detect from current repo
LABEL="${PRCHECK_DEFAULT_LABEL:-}"      # default label comes from env; no default when unset
NO_LABEL=false       # use -L / --no-label to ignore label filtering
GH_USER=""                             # default: detect from gh auth (cached)
LIMIT=50
INCLUDE_REVIEW_REQUESTED=false
TITLE_AS_HYPERLINK=true  # use --no-title-as-hyperlink to disable hyperlinks
JSON_OUTPUT=false  # use --json to output JSON instead of table
# Comma-separated GitHub logins to include (empty means no author filtering)
AUTHORS="${PRCHECK_AUTHORS:-}"
# internal flags to know whether user explicitly set values via CLI
USER_SET=false
REPO_SET=false

print_help() {
  cat <<EOF
Usage: $0 [options]

Options:
  -r, --repo OWNER/REPO           Repository (default: \\${REPO:-auto})
  -l, --label LABEL               Filter by label (default: \$PRCHECK_DEFAULT_LABEL; none if unset)
  -L, --no-label                  Do not filter by label
  -a, --authors USER1,USER2       Comma-separated authors (GitHub logins) to include
  -u, --user USERNAME             Your GitHub username (default: \\${GH_USER})
  -n, --limit N                   Max PRs to fetch (default: \\${LIMIT})
      --include-review-requested  Include PRs where you are review-requested
      --title-as-hyperlink        Title embeds URL (default)
      --no-title-as-hyperlink     Show URL as separate column
  -j, --json                      Output JSON instead of table
  -h, --help                      Show this help

Examples:
  $0
  $0 -r myorg/myrepo -l "Platform" -u myuser -n 100 --include-review-requested
  $0 -L
  $0 --no-title-as-hyperlink
  $0 -a user1,user2

Requires: gh (authenticated with repo scope), jq, jtbl.
EOF
}

# --- Parse args ---
while [[ $# -gt 0 ]]; do
  case "$1" in
    -r|--repo) REPO="$2"; REPO_SET=true; shift 2;;
    -l|--label) LABEL="$2"; NO_LABEL=false; shift 2;;
    -L|--no-label) NO_LABEL=true; shift;;
    -a|--authors) AUTHORS="$2"; shift 2;;
    -u|--user) GH_USER="$2"; USER_SET=true; shift 2;;
    -n|--limit) LIMIT="$2"; shift 2;;
    --include-review-requested) INCLUDE_REVIEW_REQUESTED=true; shift;;
    --title-as-hyperlink) TITLE_AS_HYPERLINK=true; shift;;
    --no-title-as-hyperlink) TITLE_AS_HYPERLINK=false; shift;;
    -j|--json) JSON_OUTPUT=true; shift;;
    -h|--help) print_help; exit 0;;
    *) echo "[prcheck] Error: Unknown option: $1" >&2; print_help; exit 1;;
  esac
done

# --- Checks ---
command -v gh >/dev/null 2>&1 || { echo "[prcheck] Error: gh (GitHub CLI) is not installed. (brew install gh)" >&2; exit 1; }
command -v jq >/dev/null 2>&1 || { echo "[prcheck] Error: jq is not installed. (brew install jq)" >&2; exit 1; }
if [ "$JSON_OUTPUT" = false ]; then
  command -v jtbl >/dev/null 2>&1 || { echo "[prcheck] Error: jtbl is not installed. (brew install jtbl)" >&2; exit 1; }
fi

if ! gh auth status >/dev/null 2>&1; then
  echo "[prcheck] Error: gh is not authenticated. Run: gh auth login" >&2
  exit 1
fi

# Check that gh has the required 'repo' scope
GH_SCOPES=$(gh auth status 2>&1 | grep -i "Token scopes:" | head -1 | sed "s/.*Token scopes: //; s/'//g")
if [[ ! "$GH_SCOPES" =~ repo ]]; then
  echo "[prcheck] Error: gh token is missing the required 'repo' scope." >&2
  echo "[prcheck]        Current scopes: $GH_SCOPES" >&2
  echo "[prcheck]        This script requires the 'repo' scope to access:" >&2
  echo "[prcheck]          - PR information and reviews" >&2
  echo "[prcheck]          - File viewer state (which files you've viewed)" >&2
  echo "[prcheck]        To refresh with correct scopes, run: gh auth refresh -s repo" >&2
  exit 1
fi

# --- Resolve defaults (user, repo, label from env already handled) ---
# Create a small cache for metadata like GH user (separate from API response cache)
META_CACHE_DIR="/tmp/prcheck_cache"
mkdir -p "$META_CACHE_DIR"

# Extracted helpers to reduce nested conditionals
resolve_gh_user() {
  # Early return if user explicitly provided or already resolved
  if [ "$USER_SET" = true ] || [ -n "${GH_USER}" ]; then
    return 0
  fi

  local cache_file="$META_CACHE_DIR/gh_user_login.txt"
  local ttl=86400  # 24 hours
  local use_cache=false

  if [ -f "$cache_file" ]; then
    local mtime
    if stat -f %m "$cache_file" >/dev/null 2>&1; then
      mtime=$(stat -f %m "$cache_file")
    else
      mtime=$(stat -c %Y "$cache_file")
    fi
    local now
    now=$(date +%s)
    local age=$(( now - mtime ))
    if [ "$age" -lt "$ttl" ]; then
      use_cache=true
    fi
  fi

  if [ "$use_cache" = true ]; then
    GH_USER=$(cat "$cache_file" 2>/dev/null || true)
    if [ -n "${GH_USER}" ]; then
      return 0
    fi
  fi

  # Try gh api first
  if [ -z "${GH_USER}" ]; then
    GH_USER=$(gh api user -q .login 2>/dev/null || true)
  fi

  # Fallback: parse from gh auth status
  if [ -z "${GH_USER}" ]; then
    GH_USER=$(gh auth status 2>&1 | sed -n 's/.*Logged in to .* as \([^ ]*\).*/\1/p' | head -1 || true)
  fi

  if [ -n "${GH_USER}" ]; then
    echo "$GH_USER" > "$cache_file" || true
    return 0
  fi

  echo "[prcheck] Error: Could not determine GitHub username. Pass with -u USER or ensure gh auth is set up." >&2
  exit 1
}

resolve_repo() {
  # Early return if repo explicitly provided or already resolved
  if [ "$REPO_SET" = true ] || [ -n "${REPO}" ]; then
    return 0
  fi

  # Try gh repo view (works within a git repo with remote)
  REPO=$(gh repo view --json nameWithOwner -q .nameWithOwner 2>/dev/null || true)
  if [ -n "${REPO}" ]; then
    return 0
  fi

  # Fallback to git remote parsing
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    ORIGIN_URL=$(git config --get remote.origin.url 2>/dev/null || true)
    if [[ "$ORIGIN_URL" =~ ^git@github.com:([^/]+)/([^/.]+)(\.git)?$ ]]; then
      REPO="${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
      return 0
    elif [[ "$ORIGIN_URL" =~ ^https?://github.com/([^/]+)/([^/.]+)(\.git)?$ ]]; then
      REPO="${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
      return 0
    fi
  fi

  echo "[prcheck] Error: Could not determine repository. Run this script from within a GitHub repo or pass -r OWNER/REPO." >&2
  exit 1
}

# Resolve GitHub username from gh auth, unless provided via -u/--user
resolve_gh_user

# Resolve repository (OWNER/REPO) from current directory when not provided
resolve_repo

# If no label provided via env or flag, do not filter by label
if [ -z "${LABEL}" ]; then
  NO_LABEL=true
fi

# --- Build search query string ---
SEARCH_Q="repo:${REPO} is:pr is:open -is:draft"
if [ "$NO_LABEL" = false ]; then
  SEARCH_Q="${SEARCH_Q} label:\"${LABEL}\""
fi
if $INCLUDE_REVIEW_REQUESTED; then
  SEARCH_Q="${SEARCH_Q} review-requested:${GH_USER}"
fi
SEARCH_Q="${SEARCH_Q} sort:updated-desc"

# --- GraphQL query (single call) ---
GRAPHQL_QUERY=$(cat <<'GRAPHQL'
query($q: String!, $limit: Int!) {
  search(query: $q, type: ISSUE, first: $limit) {
    nodes {
      ... on PullRequest {
        number
        title
        url
        updatedAt
        isDraft
        author { login ... on User { name } }
        commits(last: 10) {
          nodes { commit { committedDate oid } }
        }
        reviews(last: 50) {
          nodes {
            author { login }
            state
            submittedAt
          }
        }
        files(first: 100) {
          nodes { path viewerViewedState }
          pageInfo { hasNextPage endCursor }
        }
      }
    }
  }
}
GRAPHQL
)

# --- Run and pretty-print ---
# Columns: Title | Author | Type | URL | Updated (or Title | Author | Type | Updated when hyperlinks enabled)

# Convert bash boolean to jq boolean
# When JSON output is enabled, disable hyperlinks (escape codes don't make sense in JSON)
if [ "$JSON_OUTPUT" = true ]; then
  JQ_HYPERLINK_FLAG="false"
elif [ "$TITLE_AS_HYPERLINK" = true ]; then
  JQ_HYPERLINK_FLAG="true"
else
  JQ_HYPERLINK_FLAG="false"
fi

# Cache (short TTL)
CACHE_DIR="/tmp/prcheck_cache"
CACHE_TTL="${PRCHECK_TTL:-8}"
mkdir -p "$CACHE_DIR"

# Cache key from query parameters
CACHE_KEY=$(echo "${SEARCH_Q}|${LIMIT}|${GRAPHQL_QUERY}" | shasum -a 256 | cut -d' ' -f1)
CACHE_FILE="${CACHE_DIR}/${CACHE_KEY}.json"

# Check if cache exists and is fresh (< $CACHE_TTL seconds old)
USE_CACHE=false
if [ -f "$CACHE_FILE" ]; then
  # Get file modification time (macOS uses -f %m, Linux uses -c %Y)
  if stat -f %m "$CACHE_FILE" >/dev/null 2>&1; then
    # macOS
    CACHE_MTIME=$(stat -f %m "$CACHE_FILE")
  else
    # Linux
    CACHE_MTIME=$(stat -c %Y "$CACHE_FILE")
  fi
  CACHE_AGE=$(($(date +%s) - CACHE_MTIME))
  if [ "$CACHE_AGE" -lt "$CACHE_TTL" ]; then
    USE_CACHE=true
  fi
fi

# Fetch data (from cache or API)
if [ "$USE_CACHE" = true ]; then
  GRAPHQL_RESPONSE=$(cat "$CACHE_FILE")
else
  GRAPHQL_RESPONSE=$(gh api graphql \
    -F q="$SEARCH_Q" \
    -F limit="$LIMIT" \
    -f query="$GRAPHQL_QUERY")
  echo "$GRAPHQL_RESPONSE" > "$CACHE_FILE"
fi

# Process the response
echo "$GRAPHQL_RESPONSE" \
  | jq --arg useHyperlinks "$JQ_HYPERLINK_FLAG" --arg ghUser "$GH_USER" --arg authorsCsv "$AUTHORS" '
    (.data.search.nodes // [])
    | ( if $authorsCsv == "" then [] else ($authorsCsv | split(",") | map(gsub("^\\s+|\\s+$";"")) | map(select(. != ""))) end ) as $authors
    | map(
        . as $pr
        | ($pr.reviews.nodes
            | map(select(.author.login == $ghUser))
            | (if length==0 then null else max_by(.submittedAt // "1970-01-01T00:00:00Z") end)
          ) as $myLastReview
        | ($pr.commits.nodes | map(.commit.committedDate) | any(. > ($myLastReview.submittedAt // "1970-01-01T00:00:00Z"))) as $hasCommitsNewerThanReview
        | ($pr.files.nodes | map(.viewerViewedState) | any(. != "VIEWED")) as $hasUnviewedInFirst100
        | ($pr.files.nodes | map(.viewerViewedState) | any(. == "VIEWED")) as $hasAnyViewedFiles
        | ($pr.files.pageInfo.hasNextPage // false) as $filesHasMore
        | ($myLastReview == null) as $neverReviewed
        | (if $neverReviewed then false else $hasCommitsNewerThanReview end) as $newSinceReview
        | ($hasUnviewedInFirst100 or $filesHasMore) as $unviewedFlag
        | (
            $neverReviewed
            or $newSinceReview
            or $unviewedFlag
          ) as $needsAttention
        | select($needsAttention)
        | (
            if $newSinceReview then "New Commits"
            elif $unviewedFlag then "Unviewed Files"
            elif $neverReviewed then "Never Reviewed"
            else "Unknown"
            end
          ) as $prType
        | ((.updatedAt | fromdate) | strflocaltime("%Y-%m-%d %I:%M %p %Z")) as $updatedLocal
        | (if ($pr.author.name // "" | length) > 0 then $pr.author.name else ($pr.author.login // "unknown") end) as $author
        | select((($pr.author.login // "unknown") != $ghUser))
        | select( (($authors | length) == 0) or ( ($authors | index(($pr.author.login // ""))) != null ) )
        | if $useHyperlinks == "true" then
            {
              Title: ("\u001b]8;;" + .url + "\u001b\\" + .title + "\u001b]8;;\u001b\\"),
              " Author": $author,
              "  Type": $prType,
              "   Updated": $updatedLocal
            }
          else
            {
              Title: (if (.title | length) > 50 then (.title[0:50] + "...") else .title end),
              Author: $author,
              Type: $prType,
              URL: .url,
              Updated: $updatedLocal
            }
          end
      )
' | if [ "$JSON_OUTPUT" = true ]; then cat; else jtbl --fancy; fi
